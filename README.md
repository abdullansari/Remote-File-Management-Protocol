# Remote File Management Protocol

A remote file management system is crucial for client-server communications. Why is it crucial? Well that is because it: centralizes data access and storage, oversees access control, maintains security, and oganizes files to make a structured storage and facilitate retrieval.

The Remote File Management Protocol (RFMP) provides the same services but in a more simplified manner. It has three phases: setup, operation, and closing phase.

![filetransfer](https://github.com/user-attachments/assets/b1c5b520-e6e4-43b4-b606-85c9ec80cdc2)
_Source: Pinterest._

## Setup Phase

The setup phase is just about laying down the foundations for the client-server communication. Once the client connects to the server, the application sends the following packets in this order:
1) **Start packet (client to server):** sends the starting packet containing information about the packet type, protocol name, protocol version, secured-communication respectively and is depicted as `(SS,RFMP,v1.0,1)`. The packet type (SS) is _start_, _RFMP_ is the protocol name, _v1.0_ is the protocol version, and the _1_ means that the client wants secured communication. If the client wishes for secured communication, the application sends an _encryption-packet_ (EC) immediately after the SS packet. However, if the client does not wish for secure communication then a _0_ will be placed in place of the _1_ and no additional packet will be sent immediately after the SS packet.
2) **Confirm-Connection packet (server to client):** sends the confirmation packet telling the client to start sending information packets. Note that the structure for this packet is `(CC)` if security is not required, otherwise it is `(CC,<Server_public_key>)`. The server's public key is generated by RSA algorithm and will be used to decrypt the _Session Key_ which will be explained in a moment.
3) **Encryption packet (client to server):** sends only if the _start_ packet specifies for secured communication. It contains information about the chosen encryption algorithm and credentials used to secure communication. Its structure is `(EC, Algorithm, <Session_key>, <Client_public_key>)`.

_Before we proceed further, let's clarify a few things about how the keys specified in the packets are generated as well as the type of encryption algorithm._

### Key Generation & Encryption Specification

The RFMP secured communication consists of 4 keys and 2 ciphers.

**KEYS**
- Server public/private keys.
- Client public/private keys.

**CIPHERS**
- AES cipher.
- Caesar cipher.

Now, onto how these keys get generated. Evidently, the server and client(s) produce their respective keys from their own ends. If the client chooses AES encryption then 16 random bytes are generated by the `get_random_bytes()` function within the `Crypto.Random` library-16 bytes because that is the standard key length for AES encryption and then that becomes the _Session Key_. On the other hand, if the client chose Caesar encryption then a random number between 1 and 26 is generated which then serves as the _Session Key_. 

--------------**THIS README IS STILL A WORK IN PROGRESS.**--------------
